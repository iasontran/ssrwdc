// Author: Team 17052
// Date:12/1/17
// Assignment: Secure Wireless Protocol
//
// Description: This Program handles the encryption and decryption functions of
//              the Secure Wireless Protocol Project
// Requirements:
//               Secure an audio signal for transmission
//----------------------------------------------------------------------//

//Begin Includes//
#include <Arduino.h>
#include <avr/io.h>
#include "timer.h"
#include <SD_Reader.H>
#include <SD_writer.H>
#include "aes.hpp"
int state = 0; // set state 0
//End Includes//


static void test_encrypt_cbc(uint8_t key[32], uint8_t *output);
static void test_decrypt_cbc(uint8_t key[32], uint8_t input[64]);

int main(void){

  init(); //necessary for atom ide using arduino libraries
  sei();
  uint8_t key[getKeySize()]; //key in uint8_t format
  uint8_t* ctx;

while(1){

  /*begin State Machine
    0 =  grab the keySize
    1 = Key is grabbed do nothing unless program hasnt executed
  */

  switch(state){
    case 0:
    setKey(key);
    if(!isProgramExecuted())
    {
      state = 0;
      break;
    } //end if
      PORTG &= ~(1<<PORTG5);
    state = 1;
    break;
/////////end case 0//////////////
case 1:

    if (!isProgramExecuted())
    {

      state = 0;  //If program hasnt executed properly go to state 0
      break;
    }//end if
    else
     {
       PORTG |= (1<<PORTG5);
      Serial.print("."); //Wait
      test_encrypt_cbc(key, ctx);
      test_decrypt_cbc(key, ctx);

      delay(1000);
        break;
    }//end else
///////////////end case 1///////////////
}//End state machine


  }//end while(1)
return 0;
}//End main


//Interupt based on the card detect pin, when High do nothing//
ISR (PCINT2_vect){
PORTG &= ~(1<<PORTG5);
  Serial.println("ERROR!!!:  \n No Card Inserted!");
    programExec(false); //if the card is removed reset program till
                              //card is inserted
    state = 0;                //set state back to 0
    delay(1000);              //delay to give card a chance to be fully inserted
    Serial.println("Checking For Card!");

}
//End Intererupt//

static void test_decrypt_cbc(uint8_t* key, uint8_t* input) {

  /* Array to store key for AES-256 */
  uint8_t keys[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                    0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
  /* Array to store input ciphertext block for AES-256 */
  uint8_t in[]  = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
                    0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
                    0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
                    0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };
  /* Array to store initialization vector */
  uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
  /* Array to store output plaintext block */
  uint8_t out[] = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
                    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
                    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
                    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };

  //  uint8_t buffer[64];
  uint8_t stored[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    Serial.println("Passed in ciphertext: ");
    for (int i = 0; i < 64; i++) {
      Serial.print(in[i]);
    }
    Serial.println("");

    Serial.println("Expected plaintext: ");
    for (int i = 0; i < 64; i++) {
      Serial.print(out[i]);
    }
    Serial.println("");

    Serial.println("Passed in key for decrypt: ");
    for (int i = 0; i < 32; i++) {
      Serial.print(key[i]);
    }
    Serial.println("");

    /* Ciphertext object */
    struct AES_ctx ctx;
    Serial.println("CBC decrypt: ");
    AES_init_ctx_iv(&ctx, key, iv);
    AES_CBC_decrypt_buffer(&ctx, input, 64);
    for (int i = 0; i < 64; i++) {
      Serial.print(in[i]);
    }
    Serial.println("");

    if (0 == memcmp((char*) out, (char*) input, 64)) {
        Serial.println("SUCCESS!");
    }
    else {
        Serial.println("FAILURE!");
    }

}

static void test_encrypt_cbc(uint8_t* key, uint8_t *output) {
  /* Array to store key for AES-256 */
  uint8_t keys[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                    0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
  /* Array to store output ciphertext block for AES-256 */
  uint8_t out[] = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
                    0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
                    0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
                    0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };
  /* Array to store initialization vector */
  uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
  /* Array to store input plaintext block */
  uint8_t in[]  = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
                    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
                    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
                    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };
  struct AES_ctx ctx;

  AES_init_ctx_iv(&ctx, key, iv);
  AES_CBC_encrypt_buffer(&ctx, in, 64);



  Serial.println("Passed in key for encrypt: ");
  // cursorDown();
  for (int i = 0; i < 32; i++) {
    Serial.print(key[i]);
  }
  Serial.print("\n");

  Serial.println("Produced ciphertext: ");
  for (int i = 0; i < 64; i++) {
    Serial.print(in[i]);
  }
  Serial.print("\n");
  // if (0 == memcmp((char*) out, (char*) in, 64)) {
  //     Serial.println("SUCCESS!");
  // }
  // else {
  //     Serial.println("FAILURE!");
  // }
  output = in;
}
