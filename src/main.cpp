/*
 *
 *
 *
 */
#include <Arduino.h>
#include <avr/io.h>
#include <SD_Reader.H>
#include <SD_writer.H>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#include "aes.hpp"
#include "serial.h"
#include "timer.h"
#include "lcd.h"
#include "led.h"

uint8_t* test_encrypt_cbc(uint8_t *key);
static void test_decrypt_cbc(uint8_t *key, uint8_t *input);
static void phex(uint8_t* str);
static void test_encrypt_ctr(void);
static void test_decrypt_ctr(void);
volatile uint8_t received;
volatile uint8_t received_block[64];
volatile int received_cnt;
int state = 0;

int main() {
  init(); // Initialization due to use of Arduino libraries
  sei();
  initSerial();
  initTimer1();
  initTimer0();
  initLCD();
  displayOn();
  initLED();
  received_cnt = 0;

  // Hardcoded initialization vector for encryption/decryption
  uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
  // Input plaintext block array to be passed through encryption and decryption
  uint8_t in[]  = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
                    0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
                    0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
                    0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };
  // Expected plaintext block to be used for testing
  uint8_t ptx[]  = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
                    0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
                    0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
                    0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };


  uint8_t key[getKeySize()]; //key in uint8_t format
  uint8_t *text;
  struct AES_ctx ctx1;
  struct AES_ctx ctx2;

  /*
  char* fileName = "Write.txt"; //File name here, must be small
  char* fileValue = "Custom words";//whatever you want to write here
  int n = 0;
  write(fileName,fileValue);
  */

  while(1) {
    /*
     * State Machine:
     * 0 = Grab key size
     * 1 = Key is grabbed, do nothing unless program hasn't executed
     */
    switch(state){
      case 0:
        setKey(key);
        if(!isProgramExecuted()) {
          state = 0;
          break;
        }
        PORTG &= ~(1<<PORTG5);
        state = 1;
      break;
      case 1:
        if (!isProgramExecuted()) {
          state = 0;  //If program hasnt executed properly go to state 0
          break;
        } else {
          PORTG |= (1<<PORTG5);
          //Serial.print("."); //Wait
          Serial.println("Passed in key for encrypt: ");
          for (int i = 0; i < 32; i++) {
            Serial.print(key[i], HEX);
          }
          Serial.print("\n");
          // Begin encryption process
          AES_init_ctx_iv(&ctx1, key, iv);
          AES_CBC_encrypt_buffer(&ctx1, in, 64);

          Serial.println("Produced ciphertext: ");
          for (int i = 0; i < 64; i++) {
            Serial.print(in[i], HEX);
          }
          Serial.println("");

          Serial.println("Expected plaintext: ");
          for (int i = 0; i < 64; i++) {
            Serial.print(ptx[i], HEX);
          }
          Serial.println("");

          Serial.println("Passed in key for decrypt: ");
          for (int i = 0; i < 32; i++) {
            Serial.print(key[i], HEX);
          }
          Serial.print("\n");

          Serial.println("Decrypted plaintext: ");
          // Begin decryption process
          AES_init_ctx_iv(&ctx2, key, iv);
          AES_CBC_decrypt_buffer(&ctx2, in, 64);
          for (int i = 0; i < 64; i++) {
            Serial.print(in[i], HEX);
          }
          Serial.println("");

          // Memory comparison of decrypted ciphertext for testing
          if (0 == memcmp((char*) ptx, (char*) in, 64)) {
              Serial.println("SUCCESS!");
          }
          else {
              Serial.println("FAILURE!");
          }
          // delay(1000); Testing w/o delay
          break;
        }
        break;
    }
  }

  return 0;
}

/*
 * Prints string as hex.
 */
static void phex(uint8_t* str){
  uint8_t len = 32;
  for (unsigned char i = 0; i < len; ++i) {
    Serial.println(str[i], HEX);
  }
}

/*
 * Function to decrypt block of ciphertext using cipher block chaining mode.
 */

// static void test_decrypt_cbc(void) {
//
//   /* Array to store key for AES-256 */
//   uint8_t key[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
//                     0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
//   /* Array to store input ciphertext block for AES-256 */
//   uint8_t in[]  = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
//                     0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
//                     0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
//                     0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };
//   /* Array to store initialization vector */
//   uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
//   /* Array to store output plaintext block */
//   uint8_t out[] = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
//                     0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
//                     0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
//                     0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };
//
//   //  uint8_t buffer[64];
//   uint8_t stored[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//
//     /*
//     for (unsigned int i = 0; i < sizeof(received_block); i++) {
//       stored[i] = received_block[i];
//     }
//     */
//
//     /* Ciphertext object */
//     struct AES_ctx ctx;
//
//     AES_init_ctx_iv(&ctx, key, iv);
//     AES_CBC_decrypt_buffer(&ctx, received_block, 64);
//
//     if (0 == memcmp((char*) out, (char*) received_block, 64)) {
//         // writeString("SUCCESS!");
//     }
//     else {
//         // writeString("FAILURE!");
//     }
//
// }

/*
 * Function to encrypt block of plaintext using cipher block chaining mode.
 */
// static void test_encrypt_cbc(void) {
//   /* Array to store key for AES-256 */
//   uint8_t key[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
//                     0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
//   /* Array to store output ciphertext block for AES-256 */
//   uint8_t out[] = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
//                     0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
//                     0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
//                     0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };
//   /* Array to store initialization vector */
//   uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
//   /* Array to store input plaintext block */
//   uint8_t in[]  = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
//                     0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
//                     0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
//                     0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };
//   struct AES_ctx ctx;
//
//   AES_init_ctx_iv(&ctx, key, iv);
//   AES_CBC_encrypt_buffer(&ctx, in, 64);
//   transmit_data(out);
//
//   // writeString("CBC encrypt: ");
//   // cursorDown();
//   /*
//   if (0 == memcmp((char*) out, (char*) in, 64)) {
//       writeString("SUCCESS!");
//   }
//   else {
//       writeString("FAILURE!");
//   }
//   */
// }

/*
 * Interrupt for receiving data via USART
 */
ISR(USART0_RX_vect) {

  if (received_cnt != 64) {
    LED_On();
    received = receive_data();
    received_block[received_cnt] = received;
    received_cnt++;
    LED_Off();
  }

}

/*
 * Interrupt for card detection, performs nothing when pin is high.
 */
ISR (PCINT2_vect) {
  PORTG &= ~(1<<PORTG5);
  // Serial.println("ERROR!!!:  \n No Card Inserted!");
  // If the card is removed, reset program until card is inserted
  programExec(false);
  state = 0;  // Reset state to 0
  // delay(1000); // Delay for card insertion
  // Serial.println("Checking For Card!");
}

/*
 * Counter mode related functions.
 */

 /*
static void test_xcrypt_ctr(const char* xcrypt);
static void test_encrypt_ctr(void) {
    test_xcrypt_ctr("encrypt");
}

static void test_decrypt_ctr(void) {
    test_xcrypt_ctr("decrypt");
}

static void test_xcrypt_ctr(const char* xcrypt) {
  uint8_t key[32] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
  uint8_t in[64]  = { 0x60, 0x1e, 0xc3, 0x13, 0x77, 0x57, 0x89, 0xa5, 0xb7, 0xa7, 0xf5, 0x04, 0xbb, 0xf3, 0xd2, 0x28,
                      0xf4, 0x43, 0xe3, 0xca, 0x4d, 0x62, 0xb5, 0x9a, 0xca, 0x84, 0xe9, 0x90, 0xca, 0xca, 0xf5, 0xc5,
                      0x2b, 0x09, 0x30, 0xda, 0xa2, 0x3d, 0xe9, 0x4c, 0xe8, 0x70, 0x17, 0xba, 0x2d, 0x84, 0x98, 0x8d,
                      0xdf, 0xc9, 0xc5, 0x8d, 0xb6, 0x7a, 0xad, 0xa6, 0x13, 0xc2, 0xdd, 0x08, 0x45, 0x79, 0x41, 0xa6 };

  uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };
  uint8_t out[64] = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
                      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
                      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
                      0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };

  struct AES_ctx ctx;

  AES_init_ctx_iv(&ctx, key, iv);
  AES_CTR_xcrypt_buffer(&ctx, in, 64);

  Serial.print("CTR ");
  Serial.print(xcrypt);
  Serial.print(": ");

  if (0 == memcmp((char *) out, (char *) in, 64)) {
      Serial.println("SUCCESS!");
  }
  else {
      Serial.println("FAILURE!");
  }
}
*/
